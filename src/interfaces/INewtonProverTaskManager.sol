// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.27;

import "@eigenlayer-middleware/src/libraries/BN254.sol";
import {IBLSSignatureChecker} from "@eigenlayer-middleware/src/interfaces/IBLSSignatureChecker.sol";
import {NewtonMessage} from "../core/NewtonMessage.sol";
import {INewtonPolicy} from "./INewtonPolicy.sol";

interface INewtonProverTaskManager {
    // EVENTS
    event NewTaskCreated(bytes32 indexed taskId, Task task);

    event TaskResponded(TaskResponse taskResponse, ResponseCertificate responseCertificate);

    event TaskChallengedSuccessfully(bytes32 indexed taskId, address indexed challenger);

    event TaskChallengedUnsuccessfully(bytes32 indexed taskId, address indexed challenger);

    event AttestationSpent(bytes32 indexed taskId, NewtonMessage.Attestation attestation);

    event AggregatorUpdated(address indexed previousAggregator, address indexed newAggregator);

    // STRUCTS
    // Task struct represents the minimal on-chain task data.
    // policyTaskData and policyConfig are moved to TaskResponse - operators generate these independently.
    // Task is completed when quorumNumbers are signed by at least quorumThresholdPercentage of operators.
    struct Task {
        // the unique identifier for the task
        bytes32 taskId;
        // policy client address
        address policyClient;
        // the nonce of the task
        uint32 nonce;
        // the block number when the task was created
        uint32 taskCreatedBlock;
        // the quorum threshold percentage of the task
        uint32 quorumThresholdPercentage;
        // the intent of the task
        NewtonMessage.Intent intent;
        // the signature of the intent by the intent creator
        bytes intentSignature;
        // task request WASM args - operators use this to generate policyTaskData
        bytes wasmArgs;
        // the quorum numbers of the task
        bytes quorumNumbers;
    }

    // Task response is hashed and signed by operators.
    // Operators generate policyTaskData independently using wasmArgs from Task.
    // Aggregator validates consistency of policyTaskData across operator responses.
    struct TaskResponse {
        // Can be obtained by the operator from the event NewTaskCreated.
        bytes32 taskId;
        // policy client address
        address policyClient;
        // policy id of the task (derived from policyTaskData)
        bytes32 policyId;
        // the policy address of the task (from policyTaskData)
        address policyAddress;
        // the intent of the task
        NewtonMessage.Intent intent;
        // the signature of the intent by the intent creator
        bytes intentSignature;
        // Policy evaluation result.
        bytes evaluationResult;
        // the policy task data - generated by operators, validated by aggregator
        NewtonMessage.PolicyTaskData policyTaskData;
        // policy configuration - fetched by operators from chain
        INewtonPolicy.PolicyConfig policyConfig;
    }

    // Certificate is filled by the protocol contract for each taskResponse signed by operators.
    // This Certificate is used by policy clients to attest the validity of policy evaluation result
    // during intent execution.
    // This certificate is also used by the challenger, who monitors and if invalid, raises challenge
    // with zero-knowledge proof of the policy evaluation result discrepancy.
    // NOTE: this can be used as an attestation for not just single chain but multi-chain attestation.
    struct ResponseCertificate {
        // the block number when the response certificate is created
        uint32 referenceBlock;
        // the block number when the task response expires
        uint32 responseExpireBlock;
        // the hash of the non-signers
        bytes32 hashOfNonSigners;
        // encoded signature data (NonSignerStakesAndSignature for source chains, BN254Certificate for destination)
        bytes signatureData;
    }

    // Challenge data is submitted by the challenger.
    // Contains the proof data and verification key for onchain verification of the policy evaluation result.
    // TODO: add support for risc0 zk proofs, and other proof types.
    struct ChallengeData {
        // Can be obtained by the operator from the event NewTaskCreated.
        bytes32 taskId;
        // sp1 zk proof to attest the policy evaluation result of the challenger
        bytes proof;
        // The committed proof output to verify against the task response data.
        bytes data;
    }

    // FUNCTIONS
    // NOTE: this function creates new task.
    // Task now contains minimal data - operators generate policyTaskData independently.
    function createNewTask(
        Task calldata task
    ) external;

    // NOTE: this function responds to existing tasks.
    function respondToTask(
        Task calldata task,
        TaskResponse calldata taskResponse,
        bytes calldata signatureData
    ) external;

    // NOTE: this function raises challenge to existing tasks.
    function raiseAndResolveChallenge(
        Task calldata task,
        TaskResponse calldata taskResponse,
        ResponseCertificate calldata responseCertificate,
        ChallengeData calldata challenge,
        BN254.G1Point[] calldata pubkeysOfNonSigningOperators
    ) external;

    // NOTE: this function authorizes existing task responses.
    function validateAttestation(
        NewtonMessage.Attestation calldata attestation
    ) external returns (bool);

    // NOTE: this function validates attestation directly by verifying BLS signatures
    // without waiting for respondToTask to be called.
    function validateAttestationDirect(
        Task calldata task,
        TaskResponse calldata taskResponse,
        IBLSSignatureChecker.NonSignerStakesAndSignature calldata nonSignerStakesAndSignature
    ) external returns (bool);

    // NOTE: this function challenges directly verified attestations when respondToTask
    // was never called after the taskResponseWindow has passed.
    function challengeDirectlyVerifiedAttestation(
        Task calldata task,
        TaskResponse calldata taskResponse,
        IBLSSignatureChecker.NonSignerStakesAndSignature calldata nonSignerStakesAndSignature
    ) external;

    // NOTE: getter functions for public mappings
    function taskHash(
        bytes32 taskId
    ) external view returns (bytes32);
    function taskResponseHash(
        bytes32 taskId
    ) external view returns (bytes32);
}
