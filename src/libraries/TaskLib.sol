// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.27;

import {INewtonProverTaskManager} from "../interfaces/INewtonProverTaskManager.sol";
import {INewtonPolicy} from "../interfaces/INewtonPolicy.sol";
import {NewtonMessage} from "../core/NewtonMessage.sol";
import {INewtonPolicyClient} from "../interfaces/INewtonPolicyClient.sol";
import {IERC165} from "@openzeppelin/contracts/interfaces/IERC165.sol";
import {PolicyValidationLib} from "./PolicyValidationLib.sol";

/**
 * @title TaskLib
 * @dev Library for task evaluation and result processing
 */
library TaskLib {
    /* CUSTOM ERRORS */
    error PolicyNotVerified();
    error TaskResponseMismatch();
    error EntrypointMismatch();
    error TaskMismatch(bytes32 expected, bytes32 actual);
    error InvalidTaskId();
    error InvalidPolicyId();
    error InvalidPolicyAddress();
    error InvalidIntent();
    error InvalidIntentSignature();
    error TaskAlreadyResponded(bytes32 existingResponseHash);
    error TaskAlreadyExists(bytes32 existingTaskHash);
    error TaskResponseTooLate(
        uint32 blockNumber, uint32 taskCreatedBlock, uint32 taskResponseWindowBlock
    );
    error TaskResponseWindowNotPassed(
        uint32 blockNumber, uint32 taskCreatedBlock, uint32 taskResponseWindowBlock
    );
    error OnlyPolicyClient();
    error InvalidPolicyClient();
    error InterfaceNotSupported();
    error InvalidSourceOrDestination();
    error InvalidPolicyVersion(string actual, string minimum);
    error InvalidTaskCreatedBlock();
    error TaskCreatedBlockInFuture();
    error TaskCreatedBlockTooOld();

    /* FUNCTIONS */

    /// @notice Creates a minimal task without policyTaskData validation.
    /// policyTaskData is now generated by operators independently and validated in respondToTask.
    /// @param task The task struct with offchain estimated taskCreatedBlock
    /// @param taskCreationBufferWindow Maximum allowed age of taskCreatedBlock (in blocks)
    function createTask(
        INewtonProverTaskManager.Task calldata task,
        uint32 taskCreationBufferWindow
    ) external view returns (INewtonProverTaskManager.Task memory) {
        require(
            task.intent.from != address(0) && task.intent.to != address(0),
            InvalidSourceOrDestination()
        );

        // Validate policy client interface
        bytes4 interfaceId = type(INewtonPolicyClient).interfaceId;
        (bool success, bytes memory result) = task.policyClient
            .staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId));
        require(
            success && result.length == 32 && abi.decode(result, (bool)), InterfaceNotSupported()
        );

        // Validate passed taskCreatedBlock is valid for BLS signature verification
        // The block must be > 0, < current block (required by BLSSignatureChecker),
        // and within taskCreationBufferWindow blocks of current block to prevent stale state
        require(task.taskCreatedBlock > 0, InvalidTaskCreatedBlock());
        require(task.taskCreatedBlock < uint32(block.number), TaskCreatedBlockInFuture());
        require(
            uint32(block.number) - task.taskCreatedBlock <= taskCreationBufferWindow,
            TaskCreatedBlockTooOld()
        );

        // Create task with minimal validation - policyTaskData validation moved to respondToTask
        // Use the passed taskCreatedBlock as single source of truth (offchain estimated block)
        INewtonProverTaskManager.Task memory newTask = INewtonProverTaskManager.Task({
            taskId: task.taskId,
            intent: task.intent,
            intentSignature: task.intentSignature,
            policyClient: task.policyClient,
            wasmArgs: task.wasmArgs,
            taskCreatedBlock: task.taskCreatedBlock,
            quorumNumbers: task.quorumNumbers,
            quorumThresholdPercentage: task.quorumThresholdPercentage
        });

        return newTask;
    }

    /// @notice Validates policyTaskData from TaskResponse.
    /// Called during respondToTask - operators generate policyTaskData independently.
    function validateTaskResponsePolicyData(
        INewtonProverTaskManager.TaskResponse calldata taskResponse
    ) external view returns (address policyAddress, bytes32 policyId) {
        // Validate policy client and get basic info from TaskResponse
        policyAddress = taskResponse.policyAddress;
        policyId = taskResponse.policyId;

        // Verify policyTaskData matches response fields
        require(
            taskResponse.policyTaskData.policyId == policyId, PolicyValidationLib.PolicyIdMismatch()
        );
        require(
            taskResponse.policyTaskData.policyAddress == policyAddress,
            PolicyValidationLib.PolicyAddressMismatch()
        );

        // Verify policy is verified
        require(INewtonPolicy(policyAddress).isPolicyVerified(), PolicyNotVerified());

        uint32 currentBlock = uint32(block.number);

        // Validate policy data attestations from response
        PolicyValidationLib.validatePolicyData(
            policyAddress, taskResponse.policyTaskData, currentBlock
        );
    }

    /**
     * @dev Evaluates the result of a task execution
     * @param evaluationResult The result data to evaluate
     * @return bool True if the result indicates success/true
     */
    // solhint-disable-next-line gas-calldata-parameters
    function evaluateResult(
        bytes memory evaluationResult
    ) external pure returns (bool) {
        uint256 length = evaluationResult.length;

        // Case 1: ABI-encoded bool true (32 bytes)
        if (length == 32) {
            uint256 val;
            assembly {
                val := mload(add(evaluationResult, 32))
            }
            return val == 1;
        }

        // Case 2: ABI-encoded "true" string (96+ bytes)
        // solhint-disable-next-line gas-strict-inequalities
        if (length >= 96) {
            uint256 strLen;
            assembly {
                strLen := mload(add(evaluationResult, 64))
            }
            if (strLen == 4) {
                bytes32 strData;
                assembly {
                    strData := mload(add(evaluationResult, 96))
                }
                return strData == 0x7472756500000000000000000000000000000000000000000000000000000000;
            }
        }

        return false;
    }

    /**
     * @dev Sanity checks the task response. Throws if any of the checks fail.
     * Note: policyId and policyAddress are now in TaskResponse (from operator-generated policyTaskData).
     * @param task The task
     * @param taskResponse The task response
     * @param blockNumber The block number
     * @param responseWindowBlock The response window block
     */
    function sanityCheckTaskResponse(
        INewtonProverTaskManager.Task calldata task,
        INewtonProverTaskManager.TaskResponse calldata taskResponse,
        uint32 blockNumber,
        uint32 responseWindowBlock
    ) external pure {
        require(taskResponse.taskId == task.taskId, InvalidTaskId());
        require(taskResponse.policyClient == task.policyClient, InvalidPolicyClient());
        // policyId and policyAddress are validated against policyTaskData in validateTaskResponsePolicyData
        require(taskResponse.policyId == taskResponse.policyTaskData.policyId, InvalidPolicyId());
        require(
            taskResponse.policyAddress == taskResponse.policyTaskData.policyAddress,
            InvalidPolicyAddress()
        );
        require(
            keccak256(abi.encode(taskResponse.intent)) == keccak256(abi.encode(task.intent)),
            InvalidIntent()
        );
        require(
            keccak256(taskResponse.intentSignature) == keccak256(task.intentSignature),
            InvalidIntentSignature()
        );
        require(
            blockNumber < task.taskCreatedBlock + responseWindowBlock,
            TaskResponseTooLate(blockNumber, task.taskCreatedBlock, responseWindowBlock)
        );
    }

    function sanityCheckAttestation(
        NewtonMessage.Attestation calldata attestation
    ) external view {
        require(
            attestation.policyId == INewtonPolicyClient(attestation.policyClient).getPolicyId(),
            PolicyValidationLib.PolicyIdMismatch()
        );
    }

    // onlyAttestationClient is used to restrict validateAttestation from only being called by the correct policy client
    function onlyAttestationClient(
        NewtonMessage.Attestation calldata attestation
    ) external view {
        require(msg.sender.code.length > 0, OnlyPolicyClient());

        bytes4 interfaceId = type(INewtonPolicyClient).interfaceId;

        (bool success, bytes memory result) = msg.sender
            .staticcall(abi.encodeWithSelector(IERC165.supportsInterface.selector, interfaceId));

        require(
            success && result.length == 32 && abi.decode(result, (bool)), InterfaceNotSupported()
        );

        require(msg.sender == attestation.policyClient, InvalidPolicyClient());
    }

    function taskHash(
        INewtonProverTaskManager.Task calldata task
    ) external pure returns (bytes32) {
        return keccak256(
            abi.encode(
                task.taskId,
                task.intent,
                task.intentSignature,
                task.policyClient,
                task.wasmArgs,
                task.quorumNumbers,
                task.quorumThresholdPercentage
            )
        );
    }

    /**
     * @notice Computes the consensus digest by zeroing out attestation fields
     * @param taskResponse The task response to compute the consensus digest for
     * @return The keccak256 hash of the task response with attestations zeroed
     * @dev This function creates a copy of the taskResponse, zeros out all attestation
     *      fields in policyData, then computes the hash. This enables BLS signature
     *      aggregation when operators have different ECDSA attestations but the same
     *      policy evaluation data.
     *
     *      The attestations are validated separately during task response validation -
     *      they just cannot be part of the BLS-signed digest since each operator
     *      produces a unique ECDSA signature.
     */
    function computeConsensusDigest(
        INewtonProverTaskManager.TaskResponse memory taskResponse
    ) internal pure returns (bytes32) {
        // Zero out attestation fields for consensus
        // Each operator signs policyData with their own ECDSA key, producing unique attestations.
        // By zeroing these before hashing, operators can achieve consensus on the core data.
        for (uint256 i = 0; i < taskResponse.policyTaskData.policyData.length; ++i) {
            taskResponse.policyTaskData.policyData[i].attestation = "";
        }
        return keccak256(abi.encode(taskResponse));
    }
}
